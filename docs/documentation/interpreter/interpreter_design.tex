%%% Add [final] option to the report class to switch between draft and final version of the report
%%% Use [narrowmargin] to enable narrow margins - this may impair readability.
\documentclass[a4paper, 10pt]{include/compassreport}   %Or compasslargereport if chapters are required.

\usepackage{times}
\usepackage{graphicx,caption}

\graphicspath{{figures/}}

\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
%\usepackage{amsfonts}
%\fontencoding{T4}
%\usepackage{marvosym}
%\usepackage{wasysym}
\usepackage{ifthen}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage{cmllisting}
\usepackage{subcaption}

%remove red boxes on links
\hypersetup{%
    pdfborder = {0 0 0}
}

%%Figures
\usepackage{tikz,bm,color}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{positioning,fit,calc}
\usetikzlibrary{arrows}
\usetikzlibrary{decorations.pathreplacing,patterns}
%\usepackage{color}
%\usepackage{float}
%\restylefloat{table}
% correct bad hyphenation here
%\hyphenation{op-tical net-works semi-conduc-tor}

\def\sectionautorefname{Section}
\def\subsectionautorefname{Subsection}
\def\subsubsectionautorefname{Subsection}

\DeclareMathSymbol{\B}{\mathalpha}{AMSb}{"42}
\DeclareMathSymbol{\I}{\mathalpha}{AMSb}{"49}
\DeclareMathSymbol{\N}{\mathalpha}{AMSb}{"4E}
\DeclareMathSymbol{\Pwr}{\mathalpha}{AMSb}{"50}
\DeclareMathSymbol{\Q}{\mathalpha}{AMSb}{"51}
\DeclareMathSymbol{\R}{\mathalpha}{AMSb}{"52}
\DeclareMathSymbol{\Z}{\mathalpha}{AMSb}{"5A}
\DeclareMathSymbol{\Sol}{\mathalpha}{AMSb}{"53}

\newcommand{\obsv}[1]{{\cal O}(#1)}
\newcommand{\ctrl}[1]{{\cal C}(#1)}
\newcommand{\vdot}[1]{\stackrel{.}{#1}}
\newcommand{\power}{\mathbf{P}}

\newcommand{\HS}{{\mathcal H}}

\newcommand{\Interval}{\I}

\newcommand{\ist}{\mbox{{\tt true}}}
\newcommand{\isf}{\mbox{{\tt false}}}
\newcommand{\emptytrace}{\langle~\rangle}
\newcommand{\abegin}{\mathbf{begin}}
\newcommand{\aend}{\mathbf{end}}
\newcommand{\alet}{\mathbf{let}}
\newcommand{\aendlet}{\mathbf{endlet}}
\newcommand{\ain}{\mathbf{in}}
\newcommand{\afor}{\mathbf{for}}
\newcommand{\adownto}{\mathbf{downto}}
\newcommand{\aforall}{\mathbf{foreach}}
\newcommand{\awhile}{\mathbf{while}}
\newcommand{\ado}{\mathbf{do}}
\newcommand{\aenddo}{\mathbf{enddo}}
\newcommand{\acontinue}{\mathbf{continue}}
\newcommand{\aif}{\mathbf{if}}
\newcommand{\athen}{\mathbf{then}}
\newcommand{\aelse}{\mathbf{else}}
\newcommand{\aelseif}{\mathbf{elseif}}
\newcommand{\aendif}{\mathbf{endif}}
\newcommand{\ainout}{\mathbf{inout}}
\newcommand{\aout}{\mathbf{out}}
\newcommand{\aprocedure}{\mathbf{procedure}}
\newcommand{\afunction}{\mathbf{function}}
\newcommand{\abreak}{\mathbf{break}}
\newcommand{\Sup}[1]{\overline{#1}}
\newcommand{\Inf}[1]{\underline{#1}}


\newcommand{\taba}{\hspace*{3mm}}
\newcommand{\tabb}{\hspace*{6mm}}
\newcommand{\tabc}{\hspace*{9mm}}
\newcommand{\tabd}{\hspace*{12mm}}
\newcommand{\tabe}{\hspace*{15mm}}
\newcommand{\tabf}{\hspace*{18mm}}
\newcommand{\tabg}{\hspace*{21mm}}

\newcommand{\gca}[1]{{{#1}^{\vartriangleright}}}
\newcommand{\gcb}[1]{{{#1}^{\vartriangleleft}}}
\newcommand{\gclr}{{{\vartriangleleft\atop\longleftarrow}\atop
                   {\longrightarrow\atop\vartriangleright}}}

\newcommand{\dontshow}[1]{}


\newcommand{\Nat}{{\mathbb N}}
\newcommand{\Real}{{\mathbb R}}

\newcommand{\trans}{\longrightarrow}
\newcommand{\transp}{\longrightarrow_{\power}}
\newcommand{\transl}{\longrightarrow_{L}}
\newcommand{\transg}{\longrightarrow_{G}}
\newcommand{\transcfg}[1]{\stackrel{#1}{\longrightarrow}_{CFG}}
\newcommand{\isdefd}{=_{\mbox{\footnotesize def}}}
\newcommand{\equivdef}{\equiv_{\mbox{\footnotesize def}}}
\newcommand{\mitem}{\mbox{\em M-Item}}
\newcommand{\fun}{\rightarrow}
\newcommand{\pfun}{\not\rightarrow}
\newcommand{\currt}{\hat{t}}

\newcommand{\dom}{\mbox{dom}}
\newcommand{\ran}{\text{ran}}

\newcommand{\sigmaa}{\sigma_A}
\newcommand{\strictimplies}{\stackrel{\bullet}{\Rightarrow}}


\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}

\newcommand{\todo}[2]{\marginpar{\textbf{#1:} #2}}

\newboolean{showcomments}
%\setboolean{showcomments}{true}
\setboolean{showcomments}{false}

\newcommand{\com}[1]{\ifthenelse{\boolean{showcomments}}{
           \bigskip
           \noindent
           \framebox
       {\parbox{\textwidth}{
           {\sf #1}
           }}}{}}
           

\newcounter{examplectr}[section]
\newenvironment{example}[1] 
{
{\refstepcounter{examplectr}
\bf Example~\thesection.\theexamplectr.\label{#1}}
}
{

}

\lstdefinestyle{shstyle}{basicstyle=\footnotesize\ttfamily,
			frame=trbl, 
			showstringspaces=false,  
			captionpos=b,
			frameround=tttt, 
			aboveskip=5mm, 
			belowskip=5mm,
			breaklines=true,
			tabsize=4,
			framexleftmargin=0mm, 
			framexrightmargin=0mm}
\lstnewenvironment{shell}{\lstset{style=shstyle}\lstset{language=sh}}{}


\def\draftnote#1{\smallskip\noindent\hspace*{-3em}\framebox{\color{red}\begin{minipage}{\textwidth}#1\end{minipage}}\smallskip\par}

\def\filepath{\nolinkurl}


\reportnumber{DXX}
\reporttitle{CML Interpreter Design Document}
\shortreporttitle{Simulator/Animator}  %To use if report title is too long for header

%%% Set document release class as appropriate
%%% e.g. Public, Restricted, Programme Participant
\reportstatus{Public}


%%% If document is a deliverable, this flag should be commented out 
%%% e.g. %\technotetrue
%%% If report is a technical report, leave uncommented
%%% e.g. \technotetrue
\technotetrue % Comment out as appropriate

\submissiondate{Month Year}
\contributors{
  Anders Kaels Malmos, AU 
}
\editors{
  Peter Gorm Larsen, AU
}
\reviewers{}


%% Version details  
% #1: version
% #2: date
% #3: author
% #4: description
\addversion{0.1}{25-04-2013}{Anders Kaels Malmos}{Initial document version}
\addversion{0.2}{06-03-2014}{Anders Kaels Malmos}{Added introduction and domain description}
% \addversion{0.2}{dd-mm-yyyy}{Richard Payne}{Second version}

\begin{document}
\maketitle


%%%% Document abstract page %%%% 
\section*{Abstract}
\label{sec:abstract}

This document describes the overall design of the CML
simulator/animator and provides an overview of the code structure
targeting developers.

\newpage

%%%% Document table of contents page %%%% 
\tableofcontents
\newpage

%%%% Document Content %%%% 
%% \chapter{Chapter Title} %% if compasslargereport is in use
\section{Introduction}\label{sec:introduction}
This document is targeted at developers and describes the overall
design of the CML simulator, it is not a detailed description of each
component. This kind of documentation is done in Javadoc and can be
generated automatically from the code. It is assumed that common
design patterns are known like \ref{GOF}.

\subsection{Problem Domain}
The goal of the interpreter is to enable simulation/animation of a
given CML \ref{cml syntax} model and be able to visualize this in the
Eclipse IDE Debugger. CML has a formal semantics defined in \ref{cml semantics}
which strictly dictates how the interpretation progresses describes in
the semantic framework UTP. The overall goal of the CML interpreter is
therefore to adhere to semantic rules defined in those
documents and somehow visualize this in Eclipse.

In order to understand how CML is interpreted without understanding
all the details of the semantics, a small example is given below. In
figure

\begin{cml}[caption=Coordinating a reader and writer process,tabsize=2, label={lbl:process:B}]
channels
start 
input : int
output : int

process Writer = 
begin
 @ start -> input.1 -> Skip 
end

process Reader = 
begin
 @ start -> input? x -> output!x -> Skip 
end

process System = Writer [|{start, input}|] Reader
\end{cml}

\draftnote{Write about the example in the same manner as D32.2 description}


\subsection{Definitions}
\begin{description}
\item[CML] Compass Modelling Language
\item[UTP] Unified Theory of Programming
\item[Simulation] Simulation is when the interpreter runs without
  any form of user interaction other than starting and stoppping.
\item[Animation] Animation is when the user are involved in taking
  the decisions when interpreting the CML model
\end{description}

\section{Software Layers}
\label{sec:software_layers}
This section describes the layers of the CML
interpreter. As depicted in figure \ref{fig:layers} two highlevel layers exists.

\begin{figure}[ht!]
  \begin{center}
    \includegraphics[width=1\textwidth]{figures/layers}
    \caption{The layers of the CML Interpreter}
    \label{fig:layers}
  \end{center}
\end{figure}

\begin{description}
\item[Core layer] Has the responsibility of interpreting a CML model
  as described in the operational semantics that are defined in
  \cite{D23.4} and is located in the java package named
  \emph{eu.compassresearch.core.interpreter}

\item[IDE layer] Has the responsibility of visualizing the outputs of
  a running interpretation a CML model in the Eclipse Debugger. It is
  located in the \emph{eu.compassresearch.ide.cml.interpreter\_plugin}
  package.
\end{description}

Each of these components will be described in further detail in the
following sections.

\subsection{The Core Layer}

The design philosophy of the top-level structure is to encapsulate all
the classes and interfaces that makes up the implementation of the
core functionality and only expose those that are needed to utilize
the interpreter. This provides a clean separation between the
implementation and interface and makes it clear for both the users,
which not necessarily wants to know about the implementation details,
and developers which parts they need to work with.

The following packages defines the top level structure of the core:
\begin{description}
\item[eu.compassresearch.core.interpreter.api] This package and
  sub-packages contains all the public classes and interfaces that
  defines the API of the interpreter. This package includes the main
  interpreter interface \textbf{CmlInterpreter} along with additional
  interfaces.
  The api sub-packages groups the rest of the API classes and
  interfaces according to the responsibility they have.

\item[eu.compassresearch.core.interpreter.api.behaviour] This package
  contains all the components that define any CML behavior. A CML
  behaviour is either an observable event like a channel synchronization
  or a internal event like a change of state. The main interface is
  \textbf{CmlBehaviour}.

\item[eu.compassresearch.core.interpreter.api.events] This package
  contains all the public components that enable users of the
  interpreter to subscribe to multiple on events (this it not CML
  channel events) from both \textbf{CmlIntepreter} and
  \textbf{CmlBehaviour} instances.

\item[eu.compassresearch.core.interpreter.api.transitions] This
  package contains all the possible types of transitions that a
  \textbf{CmlBehaviour} instance can make. This will be explained in
  more detail in section \ref{sec:transition_model}.

\item[eu.compassresearch.core.interpreter.api.values] This package
  contains all the values used in the CML interpreter. Values are used
  to represent the the result of an expression or the current state of a
  variable.

\item[eu.compassresearch.core.interpreter.debug] TBD

\item[eu.compassresearch.core.interpreter.utility] The utility
  packages contains components that generally reusable classes and
  interfaces. 

\item[eu.compassresearch.core.interpreter.utility.events] This package
  contains components helps to implement the Observer pattern. 

\item[eu.compassresearch.core.interpreter.utility.messaging] This
  package contains general components to pass message along a stream.

\item[eu.compassresearch.core.interpreter] This package contains all
  the internal classes and interfaces that defines the core
  functionality of the interpreter. There is one important public class
  in the package, namely the \textbf{VanillaInterpreteFactory} faactory
  class, that any user of the interpreter must invoke to use the
  interpreter. This can creates \textbf{CmlInterpreter} instances.

\end{description}

The \textbf{eu.compassresearch.core.interpreter} package are split into several
folders, each representing a different logical component. The
following folders are present

\begin{description}
\item[behavior] This folder contains all the internal classes and
  interfaces that implements the CmlBehaviors. The Cml behaviors will be
  described in more detail in in section \ref{sec:static_structure}, but
  they are bassically implemented by CML AST visitor classes.
\item[factories] This folder contains all the factories in the
  package, both the public \textbf{VanillaInterpreteFactory} that
  creates the interpreter and package internal ones.
\item[utility]
\item[...]
\end{description}

\subsection{The IDE Layer}

The IDE part is integrating the interpreter into Eclipse, enabling CML
models to be debugged/simulated/animated through the Eclipse
interface. In \autoref{fig:interpreter_debuggerDeployment} a
deployment diagram of the debugging structure is shown.

\begin{figure}[ht!]
  \begin{center}
    \includegraphics[width=1\textwidth]{figures/DebuggerDeploymentView}
    \caption{Deployment diagram of the debugger}
    \label{fig:interpreter_debuggerDeployment}
   \end{center}
\end{figure}

An Eclipse debugging session involves two JVMs, the one that the Eclipse
platform is executing in and one where only the Core executes in. All
communication between them is done via a TCP connection. 

Before explaining the steps involved in a debugging session, there are
two important classes worth mentioning:

\begin{itemize}
\item \textbf{CmlInterpreterController}: This is responsible for
  controlling the CmlInterpreter execution in the debugger JVM.  All
  communications to and from the interpreter handled in this class.
  
\item \textbf{CmlDebugTarget}: This class is part of the Eclipse
  debugging model. It has the responsiblity of representing a running
  interpreter on the Eclipse JVM side. All communications to and from
  the Eclipse debugger are handled in this class.
\end{itemize}

A debugging session has the following steps:
\begin{enumerate}
\item The user launches a debug session
\item On the Eclipse JVM a \textbf{CmlDebugTarget} instance is
  created, which listens for an incomming TCP connection.
\item A Debugger JVM is spawned and a
  \textbf{CmlInterpreterController} instance is created.
\item The \textbf{CmlInterpreterController} tries to connect to the
  created connection.
\item When the connection is established, the
  \textbf{CmlInterpreterController} instance will send a STARTING status
  message along with additional details
\item The \textbf{CmlDebugTarget} updates the GUI accordingly.
\item When the interpreter is running, status messages will be sent from \textbf{CmlInterpreterController} and commands and request messages are sent from \textbf{CmlDebugTarget}
\item This continues until \textbf{CmlInterpreterController} sends the STOPPED message
\end{enumerate}

TBD...
% \subsection{Subsection}
% \label{sec:subsection-1.1}

\section{Layer design and Implementation}
This section describes the static and dynamic structure of the
components involved in simulating/animating a CML model.

\subsection{Core Layer}

\subsubsection{Static Model}
\label{sec:static_structure}
The top level interface of the interpreter is depicted in figure
\ref{fig:interpreter_topLevelStructure}, followed by a short
description of each the depicted components.
\begin{figure}[ht!]
  \begin{center}
    \includegraphics[width=1\textwidth]{figures/toplevelStructure}
    \caption{The high level classes and interfaces of the interpreter core component}
    \label{fig:interpreter_topLevelStructure}
  \end{center}
\end{figure}

\begin{description}
\item[CmlInterpreter] The main interface exposed by
  the interpreter component. This interface has the overall
  responsibility of interpreting. It exposes methods to execute, listen
  on interpreter events and get the current state of the interpreter. It
  is implemented by the \textbf{VanillaCmlInterpreter} class.
\item[CmlBehaviour] Interface that represents a behaviour specified by
  either a CML process or action. It exposes two methods: \emph{inspect}
  which calculates the immediate set of possible transitions that the
  current behaviour allows and \emph{execute} which takes one of the
  possible transitions determined by the supervisor. A specific
  behaviour can for instance be the prefix action ``a -> P'', where the
  only possible transition is to interact in the a event.  in any
\item [CmlSupervisorEnvironment] Interface with the responsibility of
  acting as the supervisor environment for CML processes and actions. A
  supervisor environment selects and exposes the next transition/event
  that should occur to its pupils (All the CmlBehaviors under its
  supervision). It also resolves possible backtracking issues which
  may occur in the internal choice operator. 
\item[SelectionStrategy] This interface has the responsibility
  of choosing an event from a given CmlAlphabet. This responsibility is
  delegated by the CmlSupervisorEnvironment interface.
\item[CmlTransition] Interface that represents any kind of transition that
  a CmlBehavior can make. This structure will be described in more
  detail in section \ref{sec:event_structure}.
\item[CmlAlphabet] This class is a set of CmlTransitions. It exposes
  convenient methods for manipulating the set.
\end{description}

To gain a better understanding of figure
\ref{fig:interpreter_topLevelStructure} a few things needs
mentioning. First of all any CML model (at least for now) has a top
level Process. Because of this, the interpreter need only to interact
with the top level CmlBehaviour instance. This explains the one-to-one
correspondence between the CmlInterpreter and the
CMLBehaviour. However, the behavior of top level CmlBehaviour is
determined by the binary tree of CmlBehaviour instances that itself
and it's child behaviours defines. So in effect, the CmlInterpreter
controls every transition that any CmlBehaviour makes through the top
level behaviour.

\subsubsection{Transition Model}
\label{sec:transition_model}

As described in the previous section a CML model is represented by a
binary tree of CmlBehaviour instances and each of these has a set of
possible transitions that they can make. A class diagram of all the
classes and interfaces that makes up transitions are shown in figure
\ref{fig:events}, followed by a description of each of the elements.

A transition taken by a CmlBehavior is represented by a
CMLTransition. This represent a possible next step in the model which can be either observable or silent (also called a tau
transition). 

An observable transition represents either that time passes or that a
communication/synchronization event takes place on a given
channel. All of these transitions are captured in the
ObservableTransition interface.  A silent transitions is captured by
the TauTransition and HiddenTransition class and can respectively
marks the occurrence of a an internal transition of a behavior or a
hidden channel transition.

\begin{figure}[ht!]
  \begin{center}
    \includegraphics[width=1\textwidth]{figures/Events}
    \caption{The classes and interfaces that defines transitions/events}
    \label{fig:events}
  \end{center}
\end{figure}

\begin{description}
\item[CmlTransition] Represents any possible transition.
\item[CmlTransitionSet] Represents a set of CmlTransition objects.  
\item[ObservableTransition] This represents any observable transition.
\item[LabelledTransition] This represents any transition that results
  in a observable channel event
\item[TimedTransition] This represents a tock event marking the
  passage of a time unit.
\item[ObservableLabelledTransition] This represents the occurrence of
  a observable channel event which can be either a communication event
  or a synchronization event.
\item[TauTransition] This represents any non-observable transitions
  that can be taken in a behavior.
\item[HiddenEvent] This represents the occurrence of a hidden
  channel event in the form of a tau transition.
\end{description}

\subsubsection{Action/Process Structure}
\label{sec:action_process_structure}
Actions and processes are both represented by the CmlBehaviour
interface. A class diagram of the important classes that implements
this interface is shown in figure \ref{fig:cmlbehaviors}
\begin{figure}[ht!]
  \begin{center}
    \includegraphics[width=0.9\textwidth]{figures/CmlBehaviors}
    \caption{The implementing classes of the CmlBehavior interface}
    \label{fig:cmlbehaviors}
  \end{center}
\end{figure}

As shown the \textbf{ConcreteCmlBehavior} is the implementing class of
the CmlBehavior interface. However, it delegates a large part of its
responsibility to other classes. The actual behavior of a
ConcreteCmlBehavior instance is decided by its current instance of the
INode interface, so when a ConcreteCmlBehavior instance is created a
INode instance must be given. The INode interface is implemented by
all the CML AST nodes and can therefore be any CML process or action.
The actual implementation of the behavior of any process/action is
delegated to three different kinds of visitors all extending a
generated abstract visitor that have the infrastructure to visit any
CML AST node.

The following three visitors are used:  
\begin{description}
\item[AbstractSetupVisitor] This has the responsibility of performing
  any required setup for every behavior. This visitor is invoked
  whenever a new INode instance is loaded.

\item[AbstractEvaluationVisitor] This has the responsibility of
  performing the actual behavior and is invoked inside the \textbf{execute}
  method. This involves taking one of the possible transitions.

\item[AbstractAlphabetVisitor] This has the responsibility of
  calculating the alphabet of the current behavior and is invoked in the
  \textbf{inspect} method.
\end{description}

In figure \ref{fig:visitors} a more detailed look at the evaluation visitor structure is given.  

\begin{figure}[ht!]
  \begin{center}
    \includegraphics[width=1\textwidth]{figures/Visitors}
    \caption{Visitor structure}
    \label{fig:visitors}
  \end{center}
\end{figure}

As depicted the visitors are split into several visitors that handle
different parts of the languages. The sole reason for doing this is to
avoid having one large visitor that handles all the cases. At run-time
the visitors are setup in a tree structure where the top most visitor
is a \textbf{CmlEvaluationVisitor} instance which then delegates to
either a \textbf{ActionEvaluationVisitor} and
\textbf{ProcessEvaluationVisitor} etc.


\subsubsection{Dynamic Model}
\label{sec:dynamic_structure}

The previous section described the high-level static structure, this
section will describe the high-level dynamic structure.

First of all, the entire CML interpreter runs in a single thread. This
is mainly due to the inherent complexity of concurrent
programming. You could argue that since a large part of COMPASS is
about modelling complex concurrent systems, we also need a concurrent
interpretation of the models. However, the semantics is perfectly
implementable in a single thread which makes a multi-threaded
interpreter optional. There are of course benefits to a multi-threaded
interpreter such as performance, but for matters such as the testing
and deterministic behaviour a single threaded interpreter is much
easier to handle and comprehend.

To start a simulation/animation of a CML model, you first of all need
an instance of the \textbf{CmlInterpreter} interface. This is created
through the \textbf{VanillaInterpreterFactory} by invoking the
\textbf{newInterpreter} method with a typechecked AST of the CML
model. The currently returned implementation is the
\textbf{VanillaCmlInterpreter} class. Once a \textbf{CmlInterpreter}
is instantiated the interpretation of the CML model is started
by invoking the \textbf{execute} method given a
\textbf{CmlSupervisorEnvironment}.

In figure \ref{fig:dynamic_toplevel} a high level sequence diagram of
the \textbf{execute} method on the \textbf{VanillaCmlInterpreter}
class is depicted. 

\begin{figure}[ht!]
  \begin{center}
    \includegraphics[width=1\textwidth]{figures/DynamicTopLevel}
    \caption{The top level dynamics}
    \label{fig:dynamic_toplevel}
  \end{center}
\end{figure}

As seen in the figure the model is executed until the top level
process is either successfully terminated or deadlocked. For each 

\subsubsection{CmlBehaviors}

As explained in section \ref{} the CmlBehavior instances forms a binary tree at runtime. 


\subsection{The IDE Layer}
\label{sec:user_interface}

%%%% Bibliography %%%%
\newpage
\bibliographystyle{alpha}
\bibliography{bibliography} 
\label{ch:bib} %label to refer to


\end{document}  