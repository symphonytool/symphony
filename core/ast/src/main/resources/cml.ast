//TODO1: maybe generate classes with the Comparable interface
Packages
base eu.compassresearch.ast.node;
analysis eu.compassresearch.ast.analysis;

Tokens
  java_File = 'java:java.io.File';
  java_Stream = 'java:java.io.InputStream';


Abstract Syntax Tree

source {->  package='eu.compassresearch.ast.program'
		| [paragraphs]: definition* 
		| (type):type }
      = {file} [name]: java_String (file): java_File
      | {tcpStream} [ip]: java_String [port]: java_String (stream): java_Stream
      | {inputStream} [origin]: java_String (stream): java_Stream
      ;

/*
 Declarations
*/
singleDeclaration {-> package='eu.compassresearch.ast.declarations'
		| [location]:location 
		| [nameScope]:nameScope}
        = {type}
        [identifier]:LexIdentifierToken //*
        (type):type
        | {expression}
        [identifier]:LexIdentifierToken //*
        [expression]:exp
    ;
/*
 Definitions
*/
definition {-> package='eu.compassresearch.ast.definitions'}
    =   {action}
                [declarations]:parametrisation*
                [action]:action
    |   {chanset}
                [identifier]:LexIdentifierToken
                [chansetExpression]:VarsetExpression
    |   {nameset}
                [identifier]:LexIdentifierToken
                [namesetExpression]:VarsetExpression
//    |   #cmlOperation
    |   {process}
                [localState]: parametrisation*//singleDeclaration.type*
                [process]: process
    | {channel}//renamed removed Name
      //  [singleType]: singleDeclaration.type
    | #class
   | {channels}
        [channelDeclarations]: definition.channel*
   | {chansets}
        [chansets] : definition.chanset*
   | {namesets}
        [namesets] : definition.nameset*
   | {actions}
        [actions]: definition.action*
   | {types}
        [types]: definition.type*
   | {operations}
        [operations]:definition.#Operation*
   | {functions}
        (functionDefinitions):definition*
   | {values}
        [valueDefinitions]: definition*
   | {initial}
        [operationDefinition]: definition
   | {state}
        [fields]:field.field*
        [invPattern]:pattern [invExpression]:exp (invdef):definition.#Function.explicit
        [initPattern]:pattern [initExpression]:exp (initdef):definition.#Function.explicit
        (stateDefs):definition*
   ;
   
//#class {-> package='eu.compassresearch.ast.definitions'}
//	= {cml}
//        (cmlInvariant):definition.#cmlOperation.explicit
//	;

#class {-> package='eu.compassresearch.ast.definitions'}
	= {action}
       // [actionDesinitions]: definition.action*
	;
/*
 * Operations
 *
 */
//#cmlOperation {-> package='eu.compassresearch.ast.definitions'}
//    = {explicit}
//	[parameterPatterns]:pattern*
//	[body]:action
//	[isConstructor]:java_Boolean
//	[precondition]:exp
//	[postcondition]:exp
//	(type):type
//	(predef):definition.#Function.explicit
//	(postdef):definition.#Function.explicit
//	(paramDefinitions):definition*
//	(state):definition.state
//	(actualResult):type
//
//    | {implicit}
//    [parameterPatterns]:pair.patternListType*
//	[result]:pair.patternType
//	[externals]:clause.external*
//	[precondition]:exp
//	[postcondition]:exp
//	[isConstructor]:java_Boolean
//	[errors]:case.error*
//	(type):type
//	(predef):definition.#Function.explicit
//	(postdef):definition.#Function.explicit
//	(state):definition.state
//	(actualResult):type
//	(stateDefinition):definition
//    ;

/*
    Expressions
*/
exp {-> package='eu.compassresearch.ast.expressions'
	| (isVisited):java_Boolean}
    =   {bracketed} [expression]:exp /*cml*/
    |   {stateInit} (state):definition.state
    |   {tupleSelect} [tuple]:exp [entry]:java_Integer
    |   #Channel
    |   {unresolvedPath} [identifiers]:LexIdentifierToken*
    ;

#Channel  {-> package='eu.compassresearch.ast.expressions'}
        = #Rename
        | {name} [identifier]:LexIdentifierToken
                 [expressions]:exp*
        ;

#Rename   {-> package='eu.compassresearch.ast.expressions'}
        = {comprehension} [renamePairs]:pair.rename [bindings]:multipleBind* [predicate]:exp
        | {enumeration} [renamePairs]:pair.rename*
    ;

VarsetExpression {-> package='eu.compassresearch.ast.expressions'
					| [location]:location 
					| (type):type}
        = {identifier} [identifier]:LexIdentifierToken
        | {enum} [channelNames]:exp.#Channel.name*
        | {comp} [channelNameExp]:exp.#Channel.name [bindings]:multipleBind* [predicate]:exp
        | {fatEnum} [channelNames]:exp.#Channel.name*
        | {fatComp} [channelNameExp]:exp.#Channel.name [bindings]:multipleBind* [predicate]:exp
		| #VOp
	;

#VOp {-> package='eu.compassresearch.ast.expressions'
		| [left]:VarsetExpression 
		| [op]:LexToken 
		| [right]:VarsetExpression}
        = {Union}
        | {Inter}
        | {Sub}
        ;

/*
        Types
*/

type {-> package='eu.compassresearch.ast.types'}
    = //  {statement} // marker that a statement is typed ok
    //|  
     {process} [name]:LexNameToken (classdef):definition.process// marker that a process is typed ok
   // |   {error} // marker that type of a subtree has failed
 //   |   {bind}// market for a bind type subtree
 //   |   {processParagraph} // marker stipulating process paragraph is typed ok
 //   |   {chansetParagraph} // marker stipulating a chanset paragraph is typed ok
 //   |   {channelsParagraph} // marker stipulating a chanset paragraph is typed ok
 //   |   {actionParagraph} // marker stipulating that a Action Paragraph is typed ok
 //   |   {valueParagraph} // marker stipulating that a Values paragraph is typed ok
 //   |   {functionParagraph} // marker stipulating that a Function Paragraph is typed ok
 //   |   {typeParagraph} // marker stipulating that a Types Paragraph is typed ok
 //   |   {operationParagraph} // marker stipulating that a Function Paragraph is typed ok
 //   |   {stateParagraph} // marker stipulating that a state Paragraph is typed ok
 //   |   {source} // marker stipulating a source was typed ok
 //   |   {channel} (type):type // marker stipulating that a channel Paragraph is typed ok
//    |   {chanset} // marker stipulating that a chanset is typed ok
//    |   {nameset} // marker stipulating that a nameset is typed ok
 //   |   {namesets} // marker stipulating that s nameset paragraph is typed ok
  //  |   {initialParagraph} // marker
  //  |   {action} // marker
 //   |   {varsetExpression} // marker
  //  |   {paragraph} // markar that a paragraph tree is typed ok
    ;

access  {-> package='eu.compassresearch.ast.definitions'}
    =   {logical}
    ;

/*
        Patterns
*/

pair {-> package='eu.compassresearch.ast.patterns'}
    = {rename} [from]:exp.#Channel.name [to]:exp.#Channel.name
    ;

/*
        Process
*/
process {-> package='eu.compassresearch.ast.process'
		| [location]:location}
        = {action}	    //     [definitionParagraphs]:definition*
           		[actionDefinition]:definition.#class.action
                [action]:action
        | {sequentialComposition}
                [left]:process
                [right]:process
        | {externalChoice}
                [left]:process
                [right]:process
        | {internalChoice}
                [left]:process
                [right]:process
        | {generalisedParallelism}
                [left]:process
                [chansetExpression]:VarsetExpression
                [right]:process
        | {alphabetisedParallelism}
                [left]:process
                [leftChansetExpression]:VarsetExpression
                [rightChansetExpression]:VarsetExpression
                [right]:process
        | {synchronousParallelism}
                [left]:process
                [right]:process
        | {interleaving}
                [left]:process
                [right]:process
        | {interrupt}
                [left]:process
                [right]:process
        | {timedInterrupt}
                [left]:process
                [timeExpression]:exp
                [right]:process
        | {untimedTimeout}
                [left]:process
                [right]:process
        | {timeout}
                [left]:process
                [timeoutExpression]:exp
                [right]:process
        | {hiding}
                [left]:process
                [chansetExpression]:VarsetExpression
        | {skip}
        | {startDeadline}
                [left]:process
                [expression]:exp
        | {endDeadline}
                [left]:process
                [expression]:exp
        | {instantiation}
                [parametrisations]:parametrisation*
                [process]: process
                [args]:exp*
        | {reference}
                [processName]:LexNameToken
                [args]:exp*
                (processDefinition):definition.process
        | {channelRenaming}
                [process]:process
                [renameExpression]:exp.#Channel.#Rename
        | #Replicated
        ;

#Replicated {-> package='eu.compassresearch.ast.process'
		| [replicationDeclaration]:singleDeclaration* 
		| [replicatedProcess]:process}
        = {sequentialComposition}
        | {externalChoice}
        | {internalChoice}
        | {generalisedParallelism}
                [chansetExpression]:VarsetExpression
        | {alphabetisedParallelism}
                [chansetExpression]:VarsetExpression
        | {synchronousParallelism}
        | {interleaving}
        ;


/*
        Actions
*/
action {-> package='eu.compassresearch.ast.actions'
		| [location]:location
		| (type):type}
        = {skip} //what is the semantic meaning of CML skip vs VDM skip?
        | {stop}
        | {chaos}
        | {div}
        | {wait}
                [expression]:exp
        | {communication}
                [identifier]:LexIdentifierToken
                [communicationParameters]:communicationParameter*
                [action]:action
        | {guarded}
                [expression]:exp
                [action]:action
        | {sequentialComposition}
                [left]:action
                [right]:action
        | {externalChoice}
                [left]:action
                [right]:action
        | {internalChoice}
                [left]:action
                [right]:action
        | {interrupt}
                [left]:action
                [right]:action
        | {timedInterrupt}
                [left]:action
                [right]:action
                [timeExpression]:exp
        | {untimedTimeout}
                [left]:action
                [right]:action
        | {timeout}
                [left]:action
                [right]:action
                [timeoutExpression]:exp
        | {hiding}
                [left]:action
                [chansetExpression]:VarsetExpression
        | {startDeadline}
                [left]:action
                [expression]:exp
        | {endDeadline}
                [left]:action
                [expression]:exp
        | {channelRenaming}
                [action]:action
                [renameExpression]:exp.#Channel.#Rename
        | {mu}
                [identifiers]:LexIdentifierToken*
                [actions]:action*
        | #Parallel
        | {parametrised}
                [parametrisations]:parametrisation*
                [action]:action
        | #Instantiated
        | #Replicated
        //| #Statement
        | {stm} [statement]:stm
        |   {call} [name]:LexNameToken [args]:exp*
       // | {subclassResponsibility}
        | {reference}
                [name]:LexNameToken
                [args]:exp*
                (actionDefinition):definition.action
        ;

#Parallel {-> package='eu.compassresearch.ast.actions'
			| [leftAction]:action
            | [leftNamesetExpression]:VarsetExpression
            | [rightNamesetExpression]:VarsetExpression
            | [rightAction]:action}
        = {interleaving}
        | {generalisedParallelism}
                [chansetExpression]:VarsetExpression
        | {alphabetisedParallelism}
                [leftChansetExpression]:VarsetExpression
                [rightChansetExpression]:VarsetExpression
        | {synchronousParallelism}
        ;

#Replicated {-> package='eu.compassresearch.ast.actions'
			| [replicationDeclaration]:singleDeclaration* 
			| [replicatedAction]:action}
        = {sequentialComposition}
        | {externalChoice}
        | {internalChoice}
        | {commonInterleaving}
                [namesetExpression]:VarsetExpression
        | {interleaving}
                [namesetExpression]:VarsetExpression
        | {generalisedParallelism}
                [chansetExpression]:VarsetExpression
                [namesetExpression]:VarsetExpression
        | {alphabetisedParallelism}
                [namesetExpression]:VarsetExpression
                [chansetExpression]:VarsetExpression
        | {synchronousParallelism}
                [namesetExpression]:VarsetExpression
        ;

#Instantiated {-> package='eu.compassresearch.ast.actions'}
        = //dead node ->{declaration} [declaration]:definition.local*/*singleDeclaration.type**/ [action]:action [args]:exp*
        //| 
        {parametrised} [action]:action.parametrised  [args]:exp*
        ;

communicationParameter {-> package='eu.compassresearch.ast.actions'
		|	[location]:location 
		|	[expression]:exp}
        = {read} [pattern]:pattern
        | {write}
        | {signal}
        ;

parametrisation {-> package='eu.compassresearch.ast.actions'
		| [location]:location 
		| [declaration]:definition.local//singleDeclaration.type
		}
        = {val}
        | {res}
        | {vres}
        ;

/*

#Statement {-> package='eu.compassresearch.ast.actions'}
        = {let} [action]:action [localDefinitions]:definition* //this is just defletdef
        | 
        {block} [declareStatement]:action.#Statement.declare [action]:action //same but only with one in the lsit
        | {nonDeterministicIf} //move to sub in stm
                [alternatives]:action.#Statement.nonDeterministicAlt*	
        | {nonDeterministicAlt}//move to sub in stm
                [guard]:exp
                [action]:action
        | {if}  //same
                [ifExp]:exp
                [thenStm]:action
                [elseIf]:action.#Statement.elseIf*
                [elseStm]:action
        | {elseIf} //same
                [elseIf]:exp
                [thenStm]:action
        | {cases} //same
                [exp]:exp
                [cases]:alternativeAction.case*
                [others]:action
        | #GeneralAssignment
        | {specification} //copy ex errors
                [externals]:clause.external*
                [precondition]:exp
                [postcondition]:exp
        | {call} //copy - bad version name.module is used to indicate that a callobject should have been there using '.'
                [name]:LexNameToken
                [args]:exp*
        | {assignmentCall} //maybe callObject could be used here. I dont think this node is needed - I will remove it
                [designator]:exp
                [call]:action.#Statement.call
        | {return} //copy
                [exp]:exp
    | {notYetSpecified} //copy
                [opname]:LexNameToken
                [args]:exp*
    | {new} //new - we keep this but move it to a proper statement
        [destination]:exp
        [className]:LexNameToken
        [args]:exp*
        (classdef):definition.#class
        (ctorDefinition):definition
    | {nonDeterministicDo}//move to sub in stm
        [alternatives]:action.#Statement.nonDeterministicAlt*
    | {forSet} //=forAll
        [pattern]:pattern
        [set]:exp
        [action]:action
    | {forIndex} //copy
        [var]:LexNameToken
        [from]:exp
        [to]:exp
        [by]:exp
        [action]:action
    | {forSequence} // forPatternBind
        [patternBind]:patternBind.def
        [exp]:exp
        [action]:action
        (seqType):type.#seq
    | {while} //copy
        [condition]:exp
        [action]:action
     | 
     {declare}  [assignmentDefs]:definition*
        ;
     
*/
/*#GeneralAssignment {-> package='eu.compassresearch.ast.actions'}
    = {single} [stateDesignator]:exp [expression]:exp //assignment but need a unresolved statedesignator
    | {multiple} [assignments]:action.#Statement.#GeneralAssignment.single* //atomic
        ;
 
 */
        
stateDesignator {-> package='org.overture.ast.statements'}
	=	{unresolved} [path]:exp//well we wanted this:exp.unresolvedPath
	;
	
	
objectDesignator {-> package='org.overture.ast.statements'}
    =  {unresolved} [path]:exp//well we wanted this:exp.unresolvedPath
    ;

/*alternativeAction {-> package='eu.compassresearch.ast.actions'}
    = {case} [location]:location [pattern]:pattern* [result]:action (defs):definition*
    ;
  */  
    
/*
* Real statements
*/
stm {-> package='org.overture.ast.statements'
	|	[location]:location 
	|	(type):type}
    =   {action} [action]:action
    |	{new} 
        [destination]:stateDesignator
        [className]:LexIdentifierToken
        [args]:exp*
        //(classdef):definition.#class
        //(ctorDefinition):definition
    |	#NonDeterministic

   	;

#NonDeterministic {-> package='org.overture.ast.statements'}
	=	{if}
			[alternatives]:stm.#NonDeterministic.alt*
	|	{alt}
			[guard]:exp
			[action]:stm
	|	{do}
			[alternatives]:stm.#NonDeterministic.alt*
	;
 
